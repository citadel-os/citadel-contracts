// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import "./IExploit.sol";
import "./DiamondStorage.sol";
import "hardhat/console.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface INFT {
    function ownerOf(uint256 tokenId) external view returns (address);
}

interface IPILOT {
    function getOnchainPILOT(uint256 tokenId) external view returns (bool, uint8);
    function ownerOf(uint256 tokenId) external view returns (address);
    function getSovereign(uint256 sovereignId) external view returns (bool, uint8, uint8);
}

contract CitadelExploit is DiamondStorage, Ownable, IExploit, ReentrancyGuard {
    IERC20 public immutable drakma;
    INFT public immutable citadelCollection;
    IPilot public immutable pilotCollection;

    struct Sovereign {
        bool isSovereign;
        uint256 capitalId;
        uint256 lastBribe;
    }

    mapping(uint256 => Sovereign) public collective;

    uint256 capitalBribeAmt = 128000000000000000000000;

    constructor(
        IPilot _pilotAddress,
        INFT _citadelAddress,
        IERC20 _drakmaAddress
    ) {
        citadelCollection = _citadelAddress;
        pilotCollection = _pilotAddress;
        drakma = _drakmaAddress;
    }

    function bribeCapital(
        uint256 _sovereignId,
        uint8 _capitalId,
        uint256 _citadelId
    ) external nonReentrant {
        require(
            pilotCollection.ownerOf(_sovereignId) == msg.sender,
            "must own nft"
        );
        require(
            citadelCollection.ownerOf(_citadelId) == msg.sender,
            "must own nft"
        );
        require(isSovereign(_sovereignId), "pilot must be sovereign");

        uint256 bribeAmt = storageEngine.bribeCapital(_citadelId, _capitalId);
        require(drakma.transferFrom(msg.sender, address(this), bribeAmt));

        collective[_sovereignId].lastBribe = block.timestamp;
        collective[_sovereignId].capitalId = _capitalId;
    }

    function isSovereign(uint256 _sovereignId) internal view returns (bool) {
        if (collective[_sovereignId].lastBribe == 0) {
            return false;
        }

        return collective[_sovereignId].lastBribe <= block.timestamp;
    }

}